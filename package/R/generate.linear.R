# Generate an order-1 linear ODE system

# The system is generated by following steps:

# 1. Generating a block-diagonal matrix,
# as the linear term of the system.
# Each block is a scalar "a",
# indicating a real eigen-value,
# or of form:
#     a b
#    -b a
# which indicates a pair of complex eigen-values: a+-bi
# The analytic solution is:
#     exp(at)
# for real eigen-value, and
#     exp(at)sin(bt)
#     exp(at)cos(bt)
# for a pair of complex eigen-values.
# Each "a" is generated independently and uniform-randomly in range:
#     [real_min,real_max].
# The negative "real_min" value satisfies that the magnitude at the last
# time point is approximately half of that at the first one.
# "real_max" is half of the lower-bound.
# Each "b" should be bounded away from each other
# to decrease correlation of the system.
# Currently they are chosen as an arithmetic sequence.
# The smallest "b" is chosen to contain approximately
# one period in the time span when no real eigen-value exists,
# and double that value when there exists one real eigen-value.
# The order of "b" is permuted to break the ascension.

# 2a. Scaling coefficients in the linear term to similar magnitude.
# Disables 2b.
# Only for case of even dimension,
# and magnitude of imaginary part of eigenvalues is much larger than
# real part.
# For each 2x2 diagonal block, a similarity transformation
#     a b
#     c 1
# is applied.
# The optimal a,b,c are computed via Levenberg-Marquardt algorithm.

# 2b. Use a series of similarity transformation via orthogonal matrices
# to mix adjacent diagonal blocks.
# Disables 2a.

# 3. Permute rows and columns to make the sparsity structure less
# obvious.
# Permute rows and columns
# by left multiplying a permutation matrix
# and right multiplying its transpose to the linear term.
# This will make the sparsity structure less obvious,
# however it does not change the property,
# which means the system is still unconnected,
# if it is unconnected before this permutation.

# 4. Add constant term.

generate.linear <- function (
  dimension
  , timepoint
  , scaling = FALSE
  , orthogonal_transformation = list()
  , row_column_permutation = FALSE
  , constant = NULL
  , sanitycheck = FALSE
  , output = NULL
)

# INPUT:
# dimension: Dimension of the system.
#   Currently the system can contain complex eigen-values,
#   which appear in pairs,
#   and at most one real eigen-value,
#   since currently we have not found a good way to control
#   the correlation between curves of real eigen-values.
#   Hence if "dimension" is even, all eigen-values are complex,
#   otherwise there exists one real eigen-value in the spectrum.
# timepoint: Time points for observation data curves.
# scaling: Scaling coefficients of linear term to similar magnitude.
#   Can only be applied for even dimension.
# orthogonal_transformation: A list which applies
#   similarity transformation
#   to coefficient matrix to adjust the sparsity and structure.
#   Each component of the list is a 2-tuple (M,N)
#   A random orthogonal matrix of dimension (N-M+1) is left multiplied
#   to Mth-Nth row of the coefficient matrix,
#   and its transpose right multiplied to Mth-Nth column of the
#   coefficient matrix.
# row_column_permutation: Make the sparsity structure less obvious
#   by permuting rows and columns of the coefficient matrix.
# constant: A list of two vectors of length "dimension"
#   indicating lower and upper bounds of constant term.
#   Each component can also be a scalar,
#   which will be automatically expanded to a vector.
#   The default NULL value disables the constant term.
# sanitycheck: Whether to perform a sanity check on input arguments.
# output: Output data as pure text file.
#   NULL value disables output.
#   Should be a list consisting of:
#   file: Filename.
#   sparse: A logical to determine whether to use sparse format.
#   timefirst: A logical to determine order of output data.
#     If true, output one curve on each time-point, then next.
#     If false, output each curve on one time-point, then next.

# OUTPUT:
# initial: Initial condition of the system.
# linear: Linear term of the system.
#   It will be identical to the first column of "curve".
# eigen_complex: Complex eigenvalues of the linear term.
#   Notice that the conjugate of each element is also an eigenvalue.
# eigen_real: Real eigenvalues of the linear term.
# constant: Constant term of the system.
#   Value NULL indicates the system does not contain a constant term.
# data: Data matrix for value at given time points.
#   Each column stands for a curve.
#   First column is "timepoint".

{

ret <- list()

# Sanity check and Preprocess#{{{

if ( sanitycheck )
{

# dimension#{{{
  if (
    !is.integer(dimension)
    || length(dimension)!=1
    || dimension<=0
  )
  {
    stop('Argument "dimension" must be a positive integer.')
  }
#}}}

# timepoint#{{{
  if (
    !is.numeric(timepoint)
    || length(timepoint)<2
    || is.unsorted(timepoint,strictly=TRUE)
  )
  {
    stop('Argument "timepoint" must be a numeric vector ' ,
      'with strictly ascending elements.')
  }
#}}}

# scaling#{{{
  if (
    !is.logical(scaling)
    || length(scaling)!=1
  )
  {
    stop('Argument "scaling" must be a logical scalar.')
  }

  if (
    scaling
    && dimension%%2!=0
  )
  {
    stop('Argument "scaling" cannot be TRUE for an odd "dimension".')
  }
#}}}

# orthogonal_transformation#{{{
  if ( !is.list(orthogonal_transformation) )
  {
    stop('Argument "orthogonal_transformation" should be a list.')
  }
  if (
    scaling
    && length(orthogonal_transformation)!=0
  )
  {
    stop('Argument "orthogonal_transformation" can only be non-empty ',
      'when "scaling" is FALSE.')
  }
  for ( item in orthogonal_transformation )
  {
    if (
      !is.integer(item)
      || length(item)!=2
    )
    {
      stop('Each element of argument "orthogonal_transformation" '
        ,'must be an integer vector of length 2.')
    }
    if ( item[1]>=item[2] )
    {
      stop('In each element of argument "orthogonal_transformation", ' ,
        'the second component must be larger than first.'
      )
    }
    if ( item[1]<1 || item[2]>dimension )
    {
      stop('Out-of-bound index in elements of '
        ,'argument "orthogonal_transformation".')
    }
  }
#}}}

# row_column_permutation#{{{
  if (
    !is.logical(row_column_permutation)
    || length(row_column_permutation)!=1
  )
  {
    stop('Argument "row_column_permutation" must be a logical scalar.')
  }
#}}}

# output#{{{
  if ( !is.null(output) )
  {
    if ( !is.list(output) )
    {
      stop('Argument "output" must be a list.')
    }
    if ( !is.character(output$file) || length(output$file)!=1 )
    {
      stop('Argument "output$file" must be a string.')
    }
    if ( !is.logical(output$sparse) || length(output$sparse)!= 1 )
    {
      stop('Argument "output$sparse" must be logical.')
    }
    if ( !is.logical(output$timefirst) || length(output$timefirst)!= 1 )
    {
      stop('Argument "output$timefirst" must be logical.')
    }
  }
#}}}

}

# constant#{{{
constant_exist <- !is.null(constant)
if ( constant_exist )
{
  if (
    sanitycheck &&
    ( !is.list(constant) || length(constant)!=2 )
  )
  {
    stop('Argument "constant" must be '
      ,'a list of length two, with each element a vector or scalar.')
  }

  lapply ( 1:2 , function(index)
  {
    if ( sanitycheck && !is.numeric(constant[[index]]) )
    {
      stop('Each element of argument "constant" must be a scalar or ' ,
        'a vector of length "dimension".')
    }
    if ( length(constant[[index]])==1 )
    {
      constant[[index]] <- rep ( constant[[index]] , dimension )
    }
    else if ( sanitycheck && length(constant[[index]])!=dimension )
    {
      stop('Each element of argument "constant" must be a scalar or ' ,
        'a vector of length "dimension".')
    }
  } )
}
#}}}

#}}}

# Generate eigenvalues#{{{

num_real_eigen <- dimension%%2
num_complex_eigen <- floor(dimension/2)

time_span <- tail(timepoint,1) - timepoint[1]

real_min = -0.7/time_span
real_max = real_min/2

eigen_real <- runif (
  num_complex_eigen + num_real_eigen
  , real_min
  , real_max
)
  eigen_real[] <- real_min

eigen_imaginary <- 1:num_complex_eigen
if ( num_real_eigen>0 )
{
  eigen_imaginary <- eigen_imaginary + 1
}
eigen_imaginary <- eigen_imaginary * 2 * pi / time_span

require('permute')
permute_index <- permute::shuffle(num_complex_eigen)
permute_index <- 1:num_complex_eigen
eigen_imaginary <- eigen_imaginary[permute_index]

ret$eigen_complex <-
  1i*eigen_imaginary + eigen_real[1:num_complex_eigen]
if ( num_real_eigen==1 )
{
  ret$eigen_real <- tail(eigen_real,1)
}
else
{
  ret$eigen_real <- numeric(0)
}
#}}}

# Linear term#{{{

temp <- (1:num_complex_eigen) * 2

ret$linear <- matrix ( 0 , dimension , dimension )

ret$linear [ cbind(temp,temp) ] <-
  eigen_real[1:num_complex_eigen]
ret$linear [ cbind(temp-1,temp-1) ] <-
  eigen_real[1:num_complex_eigen]
ret$linear [ cbind(temp-1,temp) ] <-
  eigen_imaginary
ret$linear [ cbind(temp,temp-1) ] <-
  -eigen_imaginary
#}}}

# Data#{{{

ret$data <- matrix ( 0 , length(timepoint) , dimension )

lapply ( 1 : num_complex_eigen ,
  function(index)
  {
    temp <- exp ( eigen_real[index] * timepoint )
    ret$data[,2*index-1] <<-
      temp * sin ( eigen_imaginary[index] * timepoint )
    ret$data[,2*index] <<-
      temp * cos ( eigen_imaginary[index] * timepoint )
    return()
  }
)
#}}}

# Real eigenvalue#{{{

if ( num_real_eigen == 1 )
{
  ret$linear[dimension,dimension] <- tail(eigen_real,1)
  ret$data[,dimension] <- exp ( tail(eigen_real,1) * timepoint )
}
#}}}

# Initial condition#{{{

ret$initial <- rep ( 1 , dimension )
ret$initial [ 2*(1:num_complex_eigen)-1 ] <- 0
#}}}

# Scaling#{{{

if ( scaling )
{
  objective <- function (
    par
    , k
  )
  {
    ret <- numeric(3)
    temp <- k * ( par[1] - par[2]*par[3] )
    ret[1] <- par[1]*par[3] + par[2] - temp
    ret[2] <- par[1]**2 + par[2]**2 - temp
    ret[3] <- par[3]**2 + 1 - temp
    return(ret)
  }

  jacobian <- function (
    par
    , k
  )
  {
    ret <- matrix ( 0 , 3 , 3 )
    ret[1] <- par[3] - k
    ret[2] <- 2*par[1] - k
    ret[3] <- -k
    ret[4] <- 1 + par[3]*k
    ret[5] <- 2*par[2] + par[3]*k
    ret[6] <- par[3]*k
    ret[7] <- par[1] + par[2]*k
    ret[8] <- par[2]*k
    ret[9] <- 2*par[3] + par[2]*k
    return(ret)
  }

  require('minpack.lm')
  lapply ( 1 : num_complex_eigen , function(index)
  {
    scale_mat <-
      nls.lm (
        rep ( 1 , 3 )
        , lower = numeric(3)
        , upper = NULL
        , fn = objective
        , jac = jacobian
        , control = nls.lm.control()
        , k = num_complex_eigen/permute_index[index]
      ) $ par
    scale_mat <- matrix ( c(scale_mat,1) , 2 , 2 )
    temp <- (2*index-1) : (2*index)
    ret$data[,temp] <<- ret$data[,temp] %*% scale_mat
    scale_mat <- t(scale_mat)
    ret$linear[temp,temp] <<-
      scale_mat %*% ret$linear[temp,temp] %*% solve(scale_mat)
    ret$initial[temp] <<- scale_mat %*% ret$initial[temp]
  } )
}
#}}}

# Orthogonal transformation#{{{

for ( item in orthogonal_transformation )
{
  require('pracma')
  temp <- diag(dimension)
  temp [ item[1]:item[2] , item[1]:item[2] ] <-
    pracma::rortho ( item[2]-item[1]+1 )
  ret$data <- ret$data %*% t(temp)
  ret$linear <- temp %*% ret$linear %*% t(temp)
  ret$initial <- temp %*% ret$initial
}
#}}}

# Row-column permutation#{{{

if ( row_column_permutation )
{
  require('permute')
  permute_index <- permute::shuffle ( dimension )
  ret$linear <-
    ret$linear [ permute_index , permute_index ]
  ret$data <- ret$data [ , permute_index ]
  ret$initial <- ret$initial[permute_index]
}
#}}}

# Constant#{{{

if ( constant_exist )
{
  ret$constant <-
    runif ( dimension , constant[[1]] , constant[[2]] )
  temp <- solve ( ret$linear , ret$constant )
  lapply ( 1 : length(timepoint) , function(index)
  {
    ret$data[index,] <<- ret$data[index,] - temp
    return()
  } )
  ret$initial <- ret$initial - temp
}
#}}}

# Output#{{{

if ( !is.null(output) )
{
  significant_digit = 15

  sink ( output$file )

  if ( output$sparse )
  {
    cat(dimension)
    cat('\n')

    cat(length(timepoint))
    cat('\n')

    index_linear <- which ( ret$linear != 0 )
    if ( !is.null(ret$constant) )
    {
      index_constant <- which ( ret$constant != 0 )
    }

    cat(length(index_linear))
    cat('\n')

    if ( !is.null(ret$constant) )
    {
      cat(length(index_constant))
    }
    else
    {
      cat(0)
    }
    cat('\n')

    cat(formatC(timepoint,digits=significant_digit,format='g'))
    cat('\n')

    if ( output$timefirst )
    {
      cat(formatC(ret$data,digits=significant_digit,format='g'))
      cat('\n')
    }
    else
    {
      cat(formatC(t(ret$data),digits=significant_digit,format='g'))
      cat('\n')
    }

    cat(formatC(ret$initial,digits=significant_digit,format='g'))
    cat('\n')

    cat(index_linear)
    cat('\n')

    cat(formatC(ret$linear[index_linear],digits=significant_digit,format='g'))
    cat('\n')

    if ( !is.null(ret$constant) )
    {
      cat(index_constant)
      cat('\n')

      cat(formatC(ret$constant[index_constant],digits=significant_digit,format='g'))
      cat('\n')
    }
  }
  else
  {
    cat(dimension)
    cat('\n')

    cat(length(timepoint))
    cat('\n')

    cat(formatC(timepoint,digits=significant_digit,format='g'))
    cat('\n')

    if ( output$timefirst )
    {
      cat(formatC(ret$data,digits=significant_digit,format='g'))
      cat('\n')
    }
    else
    {
      cat(formatC(t(ret$data),digits=significant_digit,format='g'))
      cat('\n')
    }

    cat(formatC(ret$initial,digits=significant_digit,format='g'))
    cat('\n')

    cat(formatC(ret$linear,digits=significant_digit,format='g'))
    cat('\n')

    if ( !is.null(ret$constant) )
    {
      cat(formatC(ret$constant,digits=significant_digit,format='g'))
      cat('\n')
    }
  }

  sink()
}
#}}}

ret$data <- cbind ( timepoint , ret$data )

return(ret)

}

# vim: set tw=72 fdm=marker: Modeline for Vim
